<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design Algorithms and Analysis</title>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0f1c;
            --bg-secondary: #151f32;
            --accent: #94a3b8;
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --highlight: #38bdf8;
            --card-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        @property --gradient-angle {
            syntax: '<angle>';
            initial-value: 0deg;
            inherits: false;
        }

        body {
            font-family: Times New Roman;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            perspective: 1000px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .header {
            height: 100vh;
            display: flex;
            align-items: center;
            position: relative;
            overflow: hidden;
            justify-content: center;
        }

        .header::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 50% 50%, rgba(56, 189, 248, 0.1), transparent);
            opacity: 0;
            animation: pulseGradient 8s ease-in-out infinite;
        }

        .header-content {
            position: relative;
            z-index: 1;
            opacity: 0;
            transform: translateY(30px) rotateX(10deg);
            animation: heroEntrance 1.5s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
            text-align: center;
        }

        .title {
            font-size: clamp(2.5rem, 5vw, 4.5rem);
            font-weight: 600;
            margin-bottom: 1rem;
            line-height: 1.2;
            background: linear-gradient(var(--gradient-angle), var(--highlight), var(--text-primary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: rotateGradient 10s linear infinite;
        }

        .subtitle {
            font-size: clamp(1rem, 2vw, 1.25rem);
            color: var(--accent);
            max-width: 600px;
            margin-bottom: 2rem;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeSlideUp 0.8s ease forwards 0.5s;
        }

        .section {
            padding: 3rem;
            margin-bottom: 2rem;
            background-color: var(--bg-secondary);
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            opacity: 0;
            transform: translateY(30px);
            transition: all 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .section.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .section-title {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            position: relative;
            display: inline-block;
            color: var(--highlight);
        }

        .section-title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--highlight), transparent);
            transform: scaleX(0);
            transform-origin: center;
            animation: expandLine 0.6s ease forwards 0.5s;
        }

        @keyframes pulseGradient {
            0%, 100% { opacity: 0.1; }
            50% { opacity: 0.2; }
        }

        @keyframes rotateGradient {
            0% { background-position: 0%; }
            100% { background-position: 100%; }
        }

        @keyframes heroEntrance {
            to {
                opacity: 1;
                transform: translateY(0) rotateX(0);
            }
        }

        @keyframes fadeSlideUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes expandLine {
            to {
                transform: scaleX(1);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <div class="header-content">
                <h1 class="title">Design and Analysis of Algorthims</h1>
                <p class="subtitle">The Design and Analysis of Algorithms (DAA) is a foundational field in computer science focused on creating efficient and optimized solutions for computational problems</p>
                <p class="subtitle">Name:VARSHA C A <br> Roll no:264</p>
            </div>
        </header>

        <section class="section visible">
            <h2 class="section-title">1. Algorithmic Problem-Solving</h2>
            <p>Nature is full of problems that require efficient solutions. From the iterative patterns of seasons to recursive structures like trees and snowflakes, algorithms help us understand and solve these challenges. Algorithms like recursion, backtracking, and divide-and-conquer mirror nature’s methods for problem-solving.</p>
            <ul>
                <li><strong>Recursion:</strong> Solve problems by breaking them into smaller, similar subproblems. Examples: Fibonacci sequence, Tower of Hanoi.</li>
                <li><strong>Backtracking:</strong> Systematically explore possible solutions and backtrack when necessary. Example: N-Queens problem.</li>
            </ul>
        </section>

        <section class="section visible">
            <h2 class="section-title">2. Importance of Algorithm Efficiency</h2>
            <p>Space and time efficiency are fundamental when designing algorithms. Time efficiency ensures tasks are completed quickly, while space efficiency minimizes memory usage. These two factors are crucial in real-world applications, where limited resources demand optimized solutions to handle large data sets or fast execution.</p>
            <ul>
                <li><strong>Time Complexity:</strong> Evaluate the number of steps an algorithm takes to complete.</li>
                <li><strong>Space Complexity:</strong> Analyze memory usage during execution.</li>
            </ul>
        </section>

        <section class="section visible">
            <h2 class="section-title">3. Essential Data Structures</h2>
            <p>Choosing the right data structure can drastically improve algorithm performance. Data structures like trees, graphs, and hash tables make it easier to organize and access data efficiently, solving problems such as network connectivity, hierarchical data representation, and optimizing search operations.</p>
            <ul>
                <li><strong>Trees:</strong> Efficiently represent hierarchical data. Examples: Binary Search Tree (BST), AVL Tree.</li>
                <li><strong>Graphs:</strong> Solve network and connectivity problems using nodes and edges.</li>
                <li><strong>Hash Tables:</strong> Provide constant-time lookups for average cases.</li>
                <li><strong>Tries:</strong> Optimize string searches, as seen in autocomplete features.</li>
            </ul>
        </section>

        <section class="section visible">
            <h2 class="section-title">4. Graph Algorithms</h2>
            <p>Graph algorithms solve real-world problems in fields like transportation, social networks, and logistics. They’re used to find optimal routes, explore networks, and analyze connections between entities. These algorithms are vital in applications ranging from Google Maps to network design.</p>
            <ul>
                <li><strong>Depth-First Search (DFS):</strong> Explore as deep as possible in one branch before backtracking.</li>
                <li><strong>Breadth-First Search (BFS):</strong> Explore all nodes at one level before moving to the next.</li>
                <li><strong>Shortest Path Algorithms:</strong> Algorithms like Dijkstra and Bellman-Ford find optimal routes.</li>
                <li><strong>Minimum Spanning Tree:</strong> Use Prim’s or Kruskal’s algorithms to connect nodes with minimal total weight.</li>
            </ul>
        </section>

        <section class="section visible">
            <h2 class="section-title">5. Sorting and Searching</h2>
            <p>Sorting and searching algorithms are fundamental for efficient data management. Sorting allows quick retrieval, while searching ensures you find the right data fast. Both types of algorithms like quicksort, merge sort, binary search, and linear search are key to making data accessible and manageable.</p>
        </section>

        <section class="section visible">
            <h2 class="section-title">6. Hierarchical Data and Tree Structures</h2>
            <p>Hierarchical data structures, like trees, are widely used in areas like file systems and organizational charts. Efficiently managing these structures with algorithms like AVL trees, binary search trees, and heaps helps ensure operations such as searching, inserting, and deleting are fast and balanced.</p>
        </section>

        <section class="section visible">
            <h2 class="section-title">7. Design Techniques in Algorithms</h2>
            <p>Different algorithm design techniques, such as greedy algorithms, dynamic programming, and divide-and-conquer, each offer systematic approaches to solving problems. Greedy algorithms make quick, locally optimal choices, while dynamic programming optimizes solutions by building upon smaller subproblems. Divide-and-conquer strategies break down complex problems into manageable tasks, making them easier to solve.</p>
        </section>
        <section class="section visible">
            <h2 class="section-title">8.Space and Time efficiency</h2>
            <p>

- Space Efficiency: Refers to the extra memory an algorithm requires beyond its input data. Algorithms that use minimal additional space are considered space-efficient.  <br>

- Time Efficiency: Represents the total execution time an algorithm takes to solve a problem. Time-efficient algorithms are faster and often preferred for large-scale problems.<br>  

Efficient algorithms are crucial as they process data quicker, adapt well to growing input sizes, and consume fewer computational resources.  <br>

Class of Problems and Growth Orders: <br>
- Constant Time: Execution time does not depend on input size.<br>  
- Logarithmic Time: Runtime increases slowly as the input size grows.  <br>
- Linear Time: Execution time grows directly in proportion to input size.<br>  
- Linear Time: Grows faster than linear but slower than quadratic, often seen in efficient sorting algorithms.  <br>
- Quadratic Time: Runtime increases with the square of the input size, common in algorithms with nested loops. <br> 
- Cubic Time: Runtime grows steeper than quadratic, often in triple-nested loops.  <br>
- Exponential Time: Grows dramatically as input size increases, often impractical for large inputs.  </p>
        </section>

        <footer>
            &copy; 2024 <a href="#">Design Analysis and Algorithm</a>
        </footer>
    </div>
</body>
</html>

